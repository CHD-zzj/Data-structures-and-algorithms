# 摊还分析

摊还分析要求出数据结构的一个操作序列中所执行的所有操作的平均时间，来评价操作的代价，这种情况下即使某一个操作所需要的代价很高的时候，每一个操作的平均代价是很低的。

##  1.二项队列（二叉堆）

二项树节点的秩是儿子节点个数，以Bk的根节点的秩为k，二项队列是堆序二项树的集合，对于任意的k，最多可以存在一棵二项树Bk(二项树不能秩相同)

合并二项队列，可能两个二项队列有零，一，或三棵Bk树，如果有零或一个bk树则作为一棵树放到合并后的二项队列，如果有2棵，就合并成B(k+1)树，如果有3棵，一棵放到合并后的二项队列，剩下2棵合并为b（k+1）树后放到合并的二项队列。

位势函数：数据结构在任何时候的状态由位势函数给出，该函数不由程序保存，是计数装置，将帮助进行分析。当操作花费少于我们允许它们使用的时间时，就把没有用到的时间就以更高的位势存储起来，如果碰见更昂贵的操作就拿储备的位势来操作，二项队列的位势函数就是树的棵树，初始位势函数为0，且位势总是非负，因此摊还时间是实际时间的上界。

对于二项队列：Insert，DeleteMin，Merge的摊还运行时间分别是O（1）O（logN）O（logN）

## 2.斜堆

合并斜堆的操作：将右路径合并成为新的左路径，对新路径每个节点出去最后一个，老左子树作为右子树依附。

位势函数：如果节点的右子树后裔数是占其后裔总数的一半，则该节点是重节点，否则为轻（后裔个数包括节点本身）。位势函数是堆中重节点的个数。合并斜堆的摊还时间O为（logN）合并使右路径中的重节点一定变为轻节点，最坏情况是右路径的轻节点都变成重节点使卫视增加，把实际时间和位势变化加起来得到摊还界，可以推出摊还时间。

## 3.斐波那契堆

以O(1)摊还时间支持所有基本的堆操作的数据结构（如Insert,Merge,DecreaseKey），但是DeleteMin和Delete花费O（logN）摊还时间。

位势函数：树的棵数随级联切除而增加，所以要增加位势函数，要用位势的损失作为补偿。由于级联切除花费1单元时间并使位势+1，所以把每个标记的节点算2个位势，切除时就能消除一次级联切除次数。

## 4.二叉堆

DecreaseKey:

二叉堆中，降低元素的值，把元素向根节点上滤，直到建成堆序，最坏情形花费O（logN），但优先队列的树不具O（logN）深度时，该方法不适用（如左式堆） 将左式堆某个节点的值减低，上滤会引起堆序破坏，应将 堆切开，得到2棵树，再把这两棵树合并，此时如果2棵树都是左式堆，就可以以O(logN)合并，如果一个不是左式堆，就将其转变成左式堆。

懒惰合并：需要合并时才合并堆，但并不实际把树结合在一起。可以把2个二项树的表连在一起得到新的二项队列，但可能含有相同大小的多棵树，破坏二项队列性质，所以称其为懒惰二项队列。这种操作总是花费最坏情形时间，一次插入通过创建一个单节点二项队列并将其合并而完成。DeleteMin需要我们将懒惰二项队列转变成标准二项队列。

DeleteMin需要我们将懒惰二项队列转变成标准二项队列（每个秩只有一棵树）。找出最小元素并删除，使其每个字节点成为新的树，再合并2棵相等大小的树，直至不能合并为止，把所有树合并成一个二项队列。

位势函数与标准二项队列所用位势相同，是树的棵数，Merge,Insert的瘫痪运行时间都是O(1)，DeleteMin是O(logN)。总摊还时间是总运行时间的上界

## 5.伸展树

在节点X进行的任意树操作需要的时间正比于从根到x路径上的节点个数。单旋转记一次旋转，之字形和一字形记2次旋转，任何访问花费1+旋转次数

伸展树的秩是树的儿子节点的个数。位势函数：对伸展树每次操作都需要依次展开，所以任意操作摊还时间是一次展开的摊还时间的常数倍数之内。可以采用节点的秩的和作为位势函数
