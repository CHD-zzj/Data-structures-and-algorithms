# 贪婪算法

这是一种分阶段工作的算法，在每一个阶段可以认为所作决定是最好的，而不用考虑将来的后果，是一种近似的最优答案，也就是说局部最优不一定就是全局最优的结果，可以用来解决不要求绝对最佳答案的问题。

### 1调度问题

①一个处理器

优先执行运行时间短的作业，能够将作业平均完成时间降到最短

②多个处理器

假设作业有序，最短的先运行：按顺序开始作业，处理器间轮换分配。处理器个数能整除作业数时存在许多最优顺序。或者可以将最后完成时间最小化，可以让每个处理器的完成时间最小。

### 2文件压缩

①编码

不同字符的代码长度变化不等，经常出现的字符代码短。代表字母的二进制代码可用二叉树表示，0代表左分支，1代表右分支，从根节点开始记录路径。最优的编码要令树是满树。

②哈夫曼编码

用0指示左分支用1指示右分支，算法针对一个由树组成的森林，一棵树的权等于它的所有树叶的频率和，任意选取有最小权的两棵树T1，T2，形成以T1，T2为子树的新树，一直执行这种操作，在算法结束时得到一棵树，这棵树就是哈夫曼编码树，频率最小的字符一定是最深的节点，需要注意的是同样深度的节点字符交换不影响最优性

### 3近似装箱问题

把大小不同的n件物品转到最小数量的箱子里，每个箱子容量为1单位，所有物品都小于1单位。

----

###### 先来介绍联机算法和脱机算法

联机算法要求必须将每一个物品放入一个箱子后才处理下一件物品。

脱机算法所做的任何事情都需要等到所有的输入数据完全被读入后才进行

---

### 联机算法

①下项合适算法

处理任何物品，查看是否能装进刚刚装进物品的同一个箱子，不能就开新箱子。最差会用到几乎2倍最优装箱数箱子

②首次适合算法

依序扫描箱子，把新的物品放入足以盛下的第一个箱子中，当先前放置物品的箱子没有余位才开新箱子。最差不会多于用到最优装箱数的17/10倍

③最佳适合算法

把物品放到能容纳它的最满的箱子，比起最优不会坏过1.7倍，对随机输入表现更好。

### 脱机算法

输入数据已按大小排序。最优装箱方法用m个箱子。重量大于1/3的项会在前m个箱子内，外加的箱子中所有各项重量顶多1/3。假设放入外加箱子的物品至少m个，外加箱子中物品项数最多可以m-1,所用箱子数不超过(4m+1)/3。存在使首次适合递减法用到11/9个箱子的序列，所用箱子绝不超过（11/9m ）+4
