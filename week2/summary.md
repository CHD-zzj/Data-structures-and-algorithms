# 1.二叉查找树

特点：给树中的每个节点指定一个关键字值（在目前阶段为简便实现，关键字值都默认为整数且不会重复）

对于树中的每个节点X，他的左子树中的所有关键字值小于X的关键字值，而它的右子树中的所有关键字值大于X的关键字值

二叉查找树的难点在于元素的删除，需要分情况讨论。

1.二叉树为空树的情况 

输出这是一颗空树

2.二叉树非空情况

根指针指向的元素不等于所需要删除的元素

通过比较大小进行递归调用删除函数。

根指针指向的元素等于所需要删除的元素

如果有两个子树 则从右子树找到最小的值 代替删除元素的位置

如果有一个子树的话用不为空的子树代替所删除子树的位置

# 2.Avl树

​	Avl树主要作用是防止输入数据有序的情况下，二叉查找树退化成为链表，那样会导致数据查找的时间复杂度变大。

​	Avl树不满足平衡条件的话需要单旋转与双旋转。
(此部分代码还有些许问题没有更正)

# 3.B树

​	B树的阶为M 有以下性质 

​	树的根或者是一片树叶，或者其儿子数在2与M之间。

​	除根外，所有非树叶节点的儿子数在【M/2】（向上取整）和M之间。

​	所有树叶都在相同的深度上。

​	如过关键字节点数超过定义的范围，则需要进行分裂或合并。

# 4.散列

​	散列是通过散列函数，将带有相关值的字符串分布在大小为size的列表中。

​	理想散列函数能够把每个元素均匀散列到表里面

​	散列的主要问题是处理冲突问题，即就是当两个关键字散列到同一个值得时候该如何处理。

## 方法1：分离链接法

​	将散列到同一个值得所有元素保留在一个表中，如果产生冲突，则通过链表存储起来。
---
本周学习了二叉树，二叉查找树，AVL树和散列的一小部分。
学习了各种树的定义与特点，
理解了AVL树的单旋转和双旋转
但是代码实现起来较为困难，还有一些小问题
学习了哈希表处理矛盾的第一种方法，分离链接法
主要感受是c语言基础还比较欠缺，对于指针的理解较浅，应该尽快补上。




